'use strict';

var JSONC = require('json-comments'),
    fs = require('fs'),
    matchers = JSONC.parse(fs.readFileSync('./lib/matchers.json', 'utf8')),
    URL = require('url'),
    async = require('async'),
    _ = require('underscore');

module.exports = {
    defaults: {
        // valid link but no matches found
        link: {
            type: 'link',
            name: 'Unknown Referrer'
        },
        // referred internally 
        internal: {
            type: 'internal',
            name: 'Internal Referrer'
        },
        // referrer is blank, usually when a visitor navigates
        // to a site by typing the url into the address bar
        direct: {
            type: 'direct',
            name: 'Direct View',
            domain: '',
            url: '',
            shortened: ''
        }
    },

    /*
     * Parses document referrer into semantic information about how that visitor
     * got to the page.
     * @param  {string}   referrer Referrer url, equivalent to document.referrer
     * @param  {Function} callback callback(result);
     * where "result" is a object containing referrer information about this visitor.
     */
    parse: function(url, callback) {
        var that = this;
        var parsedReferrer = URL.parse(url || '');
        if (parsedReferrer.host && parsedReferrer.href)
            async.each(matchers, function(matcher, callback) {
                var pattern = new RegExp(matcher.pattern);
                //console.log(pattern);
                if (pattern.test(parsedReferrer.href))
                    callback(matcher.result);
                else
                    callback();
            }, function(found) {
                if (found) {
                    callback(that.addDefaultProps(parsedReferrer, found));
                } else {
                    callback(that.addDefaultProps(parsedReferrer, that.defaults.link));
                }
            });
        else
            callback(this.defaults.direct);
    },

    /*
     * Adds default properties to the results object
     * @param  {object} parsedUrl node 'url' parsed object
     * @param  {object} output	the object to append properties to and return
     * @return {object} output	object with new properties
     */
    addDefaultProps: function(parsedUrl, output) {
        output.domain = parsedUrl.host;
        output.url = parsedUrl.href;
        output.shortened = this.shortenUrl(parsedUrl.href);
        output.path = parsedUrl.pathname;
        return output;
    },

    /* 
     * Provides ExpressJS Middleware to parse the referrer and
     * adds the result to "req.referrer".
     * This first checks to see if the traffic is 'internal' else
     * tries to match to the default / user defined matchers.
     * EXAMPLE USE:
     *      var referrer = require('referrer');
     *  	app.use(referrer.middleware);
     */
    middleware: function(req, res, next) {
        var referrer = URL.parse(req.header('referrer') || '');
        var reqUrl = URL.parse(req.url || '');
        if (reqUrl.host && referrer.host && reqUrl.host === referrer.host) {
            // internally referred
            req.referrer = this.addDefaultProps(referrer, that.defaults.internal);
            next();
        } else {
            // not internal, try find a pattern match
            this.parse(referrer.href, function(result) {
                req.referrer = result;
                next();
            });
        }
    },

    /*
     * Cleans a given url and returns it without query strings/parameters
     * @param  {string} url Url
     * @return {string} 	shortened url
     */
    shortenUrl: function(url) {
        // return if url null or empty
        if (!url) return '';
        // parse url
        var parsedUrl = URL.parse(url);
        // return if no domain
        if (!parsedUrl.host) return '';
        // return shortened url
        return parsedUrl.protocol + '//' + parsedUrl.host + this.trim(parsedUrl.pathname) +
            this.getShortHash(parsedUrl.pathname, parsedUrl.hash);
    },

    /*
     * Gets a hash tag if there is no query string and the hash tag is short.
     * @param  {string} pathname Url pathname
     * @param  {string} hash     Url hash
     * @return {string}          Short hash if one is available, otherwise empty string
     */
    getShortHash: function(pathname, hash) {

        var result = '';
        if (!hash) return result;

        if ((_.isEmpty(pathname) || pathname.length < 2) &&
            (hash.length > 0 && hash.length < 20)) {

            result = '/' + trim(hash);
        }

        return result;
    },

    /*
     * Returns whether the string starts with the comparison string
     * @param  {string} str    Original string
     * @param  {string} suffic Comparison string
     * @return {boolean}    Whether the original string starts with the comparison string
     */
    endsWith: function(str, suffix) {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    },

    /*
     * Trims all ending slashes and question marks from the end of the url
     * @param  {string} str String to trim
     * @return {string}     Trimmed string
     */
    trim: function(str) {
        while (this.endsWith(str, '/') || this.endsWith(str, '?')) {
            str = str.substring(0, str.length - 1);
        }
        return str;
    },

    addMatcher: function(matcher) {

    }
};